// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: field.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const createField = `-- name: CreateField :one
INSERT INTO fields (
        field_name,
        field_type,
        field_farm_id,
        field_variety_id,
        field_polygon,  -- Assuming field_polygon is of type geometry or geography
        field_area,
        field_dieback,
        field_stage_name,
        field_status,
        field_notes
    )
VALUES ($1, $2, $3, $4, ST_GeomFromText($5), $6, $7, $8, $9, $10)
RETURNING $1, $2, $3, $4, ST_AsText(ST_GeomFromText($5, 4326)), $6
`

type CreateFieldParams struct {
	FieldName      string
	FieldType      FieldTypes
	FieldFarmID    string
	FieldVarietyID string
	StGeomfromtext interface{}
	FieldArea      string
	FieldDieback   string
	FieldStageName string
	FieldStatus    FieldStatus
	FieldNotes     string
}

type CreateFieldRow struct {
	Column1  interface{}
	Column2  interface{}
	Column3  interface{}
	Column4  interface{}
	StAstext interface{}
	Column6  interface{}
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) (CreateFieldRow, error) {
	row := q.db.QueryRowContext(ctx, createField,
		arg.FieldName,
		arg.FieldType,
		arg.FieldFarmID,
		arg.FieldVarietyID,
		arg.StGeomfromtext,
		arg.FieldArea,
		arg.FieldDieback,
		arg.FieldStageName,
		arg.FieldStatus,
		arg.FieldNotes,
	)
	var i CreateFieldRow
	err := row.Scan(
		&i.Column1,
		&i.Column2,
		&i.Column3,
		&i.Column4,
		&i.StAstext,
		&i.Column6,
	)
	return i, err
}

const getField = `-- name: GetField :one
SELECT id, field_name, field_type, field_farm_id, field_variety_id, field_polygon, field_area, field_dieback, field_stage_name, field_status, field_notes, field_creation_date, ST_AsGeoJSON(field_polygon) AS field_polygon_geojson
FROM fields
WHERE field_name = $1 AND field_farm_id = $2
LIMIT 1
`

type GetFieldParams struct {
	FieldName   string
	FieldFarmID string
}

type GetFieldRow struct {
	ID                  sql.NullInt64
	FieldName           string
	FieldType           FieldTypes
	FieldFarmID         string
	FieldVarietyID      string
	FieldPolygon        interface{}
	FieldArea           string
	FieldDieback        string
	FieldStageName      string
	FieldStatus         FieldStatus
	FieldNotes          string
	FieldCreationDate   time.Time
	FieldPolygonGeojson interface{}
}

func (q *Queries) GetField(ctx context.Context, arg GetFieldParams) (GetFieldRow, error) {
	row := q.db.QueryRowContext(ctx, getField, arg.FieldName, arg.FieldFarmID)
	var i GetFieldRow
	err := row.Scan(
		&i.ID,
		&i.FieldName,
		&i.FieldType,
		&i.FieldFarmID,
		&i.FieldVarietyID,
		&i.FieldPolygon,
		&i.FieldArea,
		&i.FieldDieback,
		&i.FieldStageName,
		&i.FieldStatus,
		&i.FieldNotes,
		&i.FieldCreationDate,
		&i.FieldPolygonGeojson,
	)
	return i, err
}

const getFieldForUpdate = `-- name: GetFieldForUpdate :one
SELECT id, field_name, field_type, field_farm_id, field_variety_id, field_polygon, field_area, field_dieback, field_stage_name, field_status, field_notes, field_creation_date, ST_AsGeoJSON(field_polygon) AS field_polygon_geojson
FROM fields
WHERE field_name = $1 AND field_farm_id = $2
LIMIT 1 FOR NO KEY
UPDATE
`

type GetFieldForUpdateParams struct {
	FieldName   string
	FieldFarmID string
}

type GetFieldForUpdateRow struct {
	ID                  sql.NullInt64
	FieldName           string
	FieldType           FieldTypes
	FieldFarmID         string
	FieldVarietyID      string
	FieldPolygon        interface{}
	FieldArea           string
	FieldDieback        string
	FieldStageName      string
	FieldStatus         FieldStatus
	FieldNotes          string
	FieldCreationDate   time.Time
	FieldPolygonGeojson interface{}
}

func (q *Queries) GetFieldForUpdate(ctx context.Context, arg GetFieldForUpdateParams) (GetFieldForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, getFieldForUpdate, arg.FieldName, arg.FieldFarmID)
	var i GetFieldForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.FieldName,
		&i.FieldType,
		&i.FieldFarmID,
		&i.FieldVarietyID,
		&i.FieldPolygon,
		&i.FieldArea,
		&i.FieldDieback,
		&i.FieldStageName,
		&i.FieldStatus,
		&i.FieldNotes,
		&i.FieldCreationDate,
		&i.FieldPolygonGeojson,
	)
	return i, err
}

const listFields = `-- name: ListFields :many
SELECT id, field_name, field_type, field_farm_id, field_variety_id, field_polygon, field_area, field_dieback, field_stage_name, field_status, field_notes, field_creation_date, ST_AsGeoJSON(field_polygon) AS field_polygon_geojson
FROM fields
ORDER BY field_name
`

type ListFieldsRow struct {
	ID                  sql.NullInt64
	FieldName           string
	FieldType           FieldTypes
	FieldFarmID         string
	FieldVarietyID      string
	FieldPolygon        interface{}
	FieldArea           string
	FieldDieback        string
	FieldStageName      string
	FieldStatus         FieldStatus
	FieldNotes          string
	FieldCreationDate   time.Time
	FieldPolygonGeojson interface{}
}

func (q *Queries) ListFields(ctx context.Context) ([]ListFieldsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFieldsRow
	for rows.Next() {
		var i ListFieldsRow
		if err := rows.Scan(
			&i.ID,
			&i.FieldName,
			&i.FieldType,
			&i.FieldFarmID,
			&i.FieldVarietyID,
			&i.FieldPolygon,
			&i.FieldArea,
			&i.FieldDieback,
			&i.FieldStageName,
			&i.FieldStatus,
			&i.FieldNotes,
			&i.FieldCreationDate,
			&i.FieldPolygonGeojson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateField = `-- name: UpdateField :one
UPDATE fields
set field_name = $1,
    field_farm_id = $2,
    field_type = $3,
    field_variety_id = $4,
    field_polygon = ST_GeomFromText($5),
    field_area = $6,
    field_dieback = $7,
    field_stage_name = $8,
    field_status = $9,
    field_notes = $10
WHERE field_name = $11 AND field_farm_id = $12
RETURNING id, field_name, field_type, field_farm_id, field_variety_id, field_polygon, field_area, field_dieback, field_stage_name, field_status, field_notes, field_creation_date
`

type UpdateFieldParams struct {
	FieldName      string
	FieldFarmID    string
	FieldType      FieldTypes
	FieldVarietyID string
	StGeomfromtext interface{}
	FieldArea      string
	FieldDieback   string
	FieldStageName string
	FieldStatus    FieldStatus
	FieldNotes     string
	FieldName_2    string
	FieldFarmID_2  string
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) (Field, error) {
	row := q.db.QueryRowContext(ctx, updateField,
		arg.FieldName,
		arg.FieldFarmID,
		arg.FieldType,
		arg.FieldVarietyID,
		arg.StGeomfromtext,
		arg.FieldArea,
		arg.FieldDieback,
		arg.FieldStageName,
		arg.FieldStatus,
		arg.FieldNotes,
		arg.FieldName_2,
		arg.FieldFarmID_2,
	)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.FieldName,
		&i.FieldType,
		&i.FieldFarmID,
		&i.FieldVarietyID,
		&i.FieldPolygon,
		&i.FieldArea,
		&i.FieldDieback,
		&i.FieldStageName,
		&i.FieldStatus,
		&i.FieldNotes,
		&i.FieldCreationDate,
	)
	return i, err
}
